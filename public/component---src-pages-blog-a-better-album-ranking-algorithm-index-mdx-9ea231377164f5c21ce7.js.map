{"version":3,"sources":["webpack:///./src/pages/blog/a-better-album-ranking-algorithm/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"weAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,gDAA+B,mBAAGC,WAAW,KAAQ,CACjD,KAAQ,oBADmB,WAA/B,sFAE2G,mBAAGA,WAAW,KAAQ,CAC7H,KAAQ,qCAD+F,aAF3G,oTAI2U,mBAAGA,WAAW,KAAQ,CAC7V,KAAQ,YAD+T,8BAJ3U,kGAOA,4HACA,6DACA,4SACA,icACA,8dACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,qDAIL,yGAAwF,0BAAYA,WAAW,KAAvB,iBAAxF,6MACA,6EACA,uHACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,4RAoBL,gKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,sKAML,iEAAgD,kBAAIA,WAAW,KAAf,YAAhD,+BAAoH,kBAAIA,WAAW,KAAf,gBAApH,0DAAuN,kBAAIA,WAAW,KAAf,kBAAvN,8EAAgV,kBAAIA,WAAW,KAAf,YAAhV,8BACA,yDACA,qLACA,sBACE,kBAAIA,WAAW,MAAf,+IACA,kBAAIA,WAAW,MAAf,qTACA,kBAAIA,WAAW,MAAf,qIACA,kBAAIA,WAAW,MAAf,oJAEF,uQAAsP,mBAAGA,WAAW,KAAQ,CACxQ,KAAQ,qEAD0O,sCAAtP,KAGA,mEAKJJ,EAAWK,gBAAiB","file":"component---src-pages-blog-a-better-album-ranking-algorithm-index-mdx-9ea231377164f5c21ce7.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"C:/Users/Nikhil17/Desktop/CodeBase/portfolio/src/templates/BlogPost.jsx\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`Years ago, I deleted my `}<a parentName=\"p\" {...{\n        \"href\": \"https://last.fm\"\n      }}>{`Last.fm`}</a>{` account, because it felt like a dying social media network. Months ago, I created `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.last.fm/user/lowmess\"\n      }}>{`a new one`}</a>{`, because Last.fm is a treasure trove of behaviorally generated personal data. It’s a lovely service for a developer to have around for side projects, as it provides instant and easy access to a large dataset with a particularly personal connection if you’re a music lover. In the process of using it for `}<a parentName=\"p\" {...{\n        \"href\": \"/about/\"\n      }}>{`one of those side projects`}</a>{`, I found a dark & disturbing secret: Last.fm actually kind of sucks for tracking album plays.`}</p>\n    <p>{`Fair warning: things are about to take a turn for the opinionated, pedantic, and downright trivial.`}</p>\n    <h2>{`The Scrobble Killed the Record Star`}</h2>\n    <p>{`Last.fm is built upon an atomic unit: the scrobble. From it, all other units are derived. A scrobble represents one play of one song, and Last.fm sets your top album by how many scrobbles it has. The problem with this is that it’s the complete wrong way to count album plays.`}</p>\n    <p>{`Album play counts are slightly different than song play counts. They should start from basically the same place — one playthrough is one playthrough — but from there they branch in subtle but important ways. For example, it is much more common to only partially listen to an album than it is to partially listen to a song. Albums are also, generally, between 10 and 12 times longer than songs, and broken into as many parts.`}</p>\n    <p>{`If the length of an album is what makes a complete playthrough of an album rarer than a playthrough of a song, a playthrough of a longer album should count for more than that of a shorter album. (There’s an argument to be made that the same is true of songs, but we’ll leave that for another day.) Thus, the ideal album ranking algorithm would account for total playthroughs, with a weight given to longer albums. Maybe even something as simple as this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`albumPlaythroughs * (1 + albumDuration / 2700)\n`}</code></pre>\n    <p>{`Here, we weight the duration in 45 minute increments, the length of a single LP (`}<inlineCode parentName=\"p\">{`albumDuration`}</inlineCode>{` being in seconds). Adding 1 to the duration calculation helps to ensure we’re not simply normalizing for record length — while that is also a valid way to rank album plays, it is not the one I prefer.`}</p>\n    <h2>{`Ok, You Got Me. Something Exactly As Simple As That`}</h2>\n    <p>{`Let’s take three albums of varying lengths and see how they handle this algorithm. Our albums:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"name\": \"Cardinal\",\n    \"artist\": \"Pinegrove\",\n    \"duration\": 1845\n  },\n  {\n    \"name\": \"Marquee Moon\",\n    \"artist\": \"Television\",\n    \"duration\": 2754\n  },\n  {\n    \"name\": \"Summertime '06\",\n    \"artist\": \"Vince Staples\",\n    \"duration\": 3545\n  }\n]\n`}</code></pre>\n    <p>{`Given one playthrough each, the three records will be ranked in exactly the same order they are now. Let’s listen to a few more tracks.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const cardinalRank = 3.5 * (1 + 1845 / 2700) // 5.89\nconst marqueeRank = 3 * (1 + 2745 / 2700) // 6.05\nconst summertimeRank = 2.5 * (1 + 3545 / 2700) // 5.78\n`}</code></pre>\n    <p>{`Now we’re getting somewhere. Even though `}<em parentName=\"p\">{`Cardinal`}</em>{` has the most playthroughs, `}<em parentName=\"p\">{`Marquee Moon`}</em>{` has the highest rank thanks to its lengthier runtime. `}<em parentName=\"p\">{`Summertime ‘06`}</em>{` is just barely in third place despite having a full playthrough less than `}<em parentName=\"p\">{`Cardinal`}</em>{`. The system works, folks.`}</p>\n    <h2>{`This Is the Part With the “But”`}</h2>\n    <p>{`Given all the information we need, the algorithm works. But we still have to get the information, and unfortunately, Last.fm doesn’t make it too easy on us:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`We can easily get a user’s top albums, but the response doesn’t include information on the amount of tracks on, or duration of, each album.`}</li>\n      <li parentName=\"ul\">{`Last.fm doesn’t use unique IDs to track albums, so we have to use an endpoint that searches by album name and artist to get detailed album information. This often fails or retrieves the wrong album, even when the album name and artist are provided by Last.fm (like from the previously discussed endpoint).`}</li>\n      <li parentName=\"ul\">{`Once we find an album, track listings are missing or incomplete about 20% of the time. This happens more often with newer albums.`}</li>\n      <li parentName=\"ul\">{`Neither the top albums nor album info endpoints give us the album’s release year. This doesn’t impact the algorithm, I just thought it was odd.`}</li>\n    </ul>\n    <p>{`All told, to implement this algorithm on our own means we would have to make an insane amount of requests just to get incomplete or missing data. If you think that doesn’t sound like it’s worth it, you’re right. And while I didn’t use it, `}<a parentName=\"p\" {...{\n        \"href\": \"https://gist.github.com/lowmess/f3c03b1a6fe50ee04622706047f8a654\"\n      }}>{`you can see an implementation here`}</a>{`.`}</p>\n    <p>{`Last.fm still ranks albums wrong, though.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}