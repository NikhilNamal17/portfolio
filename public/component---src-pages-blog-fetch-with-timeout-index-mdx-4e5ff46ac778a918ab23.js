(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{WZs5:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return c}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("FdF9");var o=n("7ljp"),r=n("wpQe");n("qKvR");function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}var i={},s={_frontmatter:i},l=r.a;function c(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(o.b)(l,a({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"I’m a big fan of the ",Object(o.b)("a",a({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"}),"Fetch API"),". I use it regularly in all sorts of projects, including this site and the API that powers the stats on the ",Object(o.b)("a",a({parentName:"p"},{href:"/about/"}),"about page"),". However it isn’t always as clear how to do things like error handling and request timeouts as it is in libraries like ",Object(o.b)("a",a({parentName:"p"},{href:"https://github.com/axios/axios"}),"Axios"),"."),Object(o.b)("p",null,"If you’re not familiar with ",Object(o.b)("inlineCode",{parentName:"p"},"fetch"),", it’s a native API that massively simplifies making AJAX requests compared to the older ",Object(o.b)("a",a({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/XMLHTTPRequest"}),"XHR")," method, and ",Object(o.b)("a",a({parentName:"p"},{href:"https://caniuse.com/#feat=fetch"}),"it’s supported in all modern browsers"),". When it initially landed, however, there was no easy way to handle request timeouts. You could fake it with ",Object(o.b)("a",a({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"}),Object(o.b)("inlineCode",{parentName:"a"},"Promise.race"))," or by ",Object(o.b)("a",a({parentName:"p"},{href:"https://github.com/github/fetch/issues/175#issuecomment-216791333"}),"wrapping your ",Object(o.b)("inlineCode",{parentName:"a"},"fetch")," in another Promise"),", but these solutions don’t actually cancel the request. This is where ",Object(o.b)("a",a({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/AbortController"}),Object(o.b)("inlineCode",{parentName:"a"},"AbortController"))," comes in."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"AbortController")," is an API that, much like its name and my previous sentence suggests, allows us to abort (cancel) requests. Though ",Object(o.b)("a",a({parentName:"p"},{href:"https://caniuse.com/#feat=abortcontroller"}),"browser support isn’t ",Object(o.b)("em",{parentName:"a"},"wonderful")," at time of writing"),", it can be used in most modern browsers and ",Object(o.b)("a",a({parentName:"p"},{href:"https://github.com/mo/abortcontroller-polyfill"}),"polyfills are available"),". The API itself has a very small surface area: a ",Object(o.b)("inlineCode",{parentName:"p"},"signal")," property to attach to request objects, and an ",Object(o.b)("inlineCode",{parentName:"p"},"abort")," method to actually cancel the request. Because the API is so simple, it’s very flexible — Jake Archibald has ",Object(o.b)("a",a({parentName:"p"},{href:"https://developers.google.com/web/updates/2017/09/abortable-fetch"}),"a fairly in-depth article on the Google Developers blog")," going over various cancellation scenarios, as well as the history behind the API, and I highly recommend giving it a read."),Object(o.b)("p",null,"With ",Object(o.b)("inlineCode",{parentName:"p"},"AbortController"),", it becomes trivial to cancel a request if it doesn’t resolve before a given period of time: if the ",Object(o.b)("inlineCode",{parentName:"p"},"abort")," method is called before the request resolves (or before the response ",Object(o.b)("inlineCode",{parentName:"p"},"Body")," is consumed), the request is cancelled; if it’s called after, the browser just ignores the call. To put it all together, we need to:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Create an instance of ",Object(o.b)("inlineCode",{parentName:"li"},"AbortController")),Object(o.b)("li",{parentName:"ol"},"Create a ",Object(o.b)("inlineCode",{parentName:"li"},"setTimeout")," function that calls the controller’s ",Object(o.b)("inlineCode",{parentName:"li"},"abort")," method"),Object(o.b)("li",{parentName:"ol"},"Pass the controller’s ",Object(o.b)("inlineCode",{parentName:"li"},"signal")," to ",Object(o.b)("inlineCode",{parentName:"li"},"fetch"),"’s options object")),Object(o.b)("h2",null,"Putting It All Together"),Object(o.b)("p",null,"First, because we’re basically writing a shim around ",Object(o.b)("inlineCode",{parentName:"p"},"fetch"),", I’m going to add an extra little perk. If the response doesn’t return in the ",Object(o.b)("inlineCode",{parentName:"p"},"200")," range (that is, if ",Object(o.b)("inlineCode",{parentName:"p"},"response.ok")," evaluates to ",Object(o.b)("inlineCode",{parentName:"p"},"false"),"), we’re going to throw an error. We absolutely do not need to do this — we could just catch our timeout and the function would work the same (we actually don’t even ",Object(o.b)("em",{parentName:"p"},"need")," to do that). However, I always perform this check anyways, so this removes a lot of boilerplate code for me."),Object(o.b)("p",null,"Anyways, here is my generic ",Object(o.b)("inlineCode",{parentName:"p"},"fetchWithTimeout")," function. It should work in any environment that supports ",Object(o.b)("inlineCode",{parentName:"p"},"fetch")," and ",Object(o.b)("inlineCode",{parentName:"p"},"AbortController"),"."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-js"}),"const fetchWithTimeout = (uri, options = {}, time = 5000) => {\n  // Lets set up our `AbortController`, and create a request options object\n  // that includes the controller's `signal` to pass to `fetch`.\n  const controller = new AbortController()\n  const config = { ...options, signal: controller.signal }\n\n  // Set a timeout limit for the request using `setTimeout`. If the body of this\n  // timeout is reached before the request is completed, it will be cancelled.\n  const timeout = setTimeout(() => {\n    controller.abort()\n  }, time)\n\n  return fetch(uri, config)\n    .then(response => {\n      // Because _any_ response is considered a success to `fetch`,\n      // we need to manually check that the response is in the 200 range.\n      // This is typically how I handle that.\n      if (!response.ok) {\n        throw new Error(`${response.status}: ${response.statusText}`)\n      }\n\n      return response\n    })\n    .catch(error => {\n      // When we abort our `fetch`, the controller conveniently throws a named\n      // error, allowing us to handle them separately from other errors.\n      if (error.name === 'AbortError') {\n        throw new Error('Response timed out')\n      }\n\n      throw new Error(error.message)\n    })\n}\n")),Object(o.b)("p",null,"Using the function is fairly straightforward. Because we return ",Object(o.b)("inlineCode",{parentName:"p"},"fetch")," directly, we can use it in much the same way; the only change should be the addition of a third parameter (our ",Object(o.b)("inlineCode",{parentName:"p"},"time")," argument) and the extra error handling we discussed above."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-js"}),"// This example _always_ logs the error, because I'm telling httpstat.us to wait\n// at least 1s before responding, but setting the timeout threshold to 500ms.\n// Also, this could definitely be written in async/await if you preferred.\nfetchWithTimeout(\n  'https://httpstat.us/200?sleep=1000',\n  { headers: { Accept: 'application/json' } },\n  500\n)\n  .then(response => response.json())\n  .then(json => {\n    console.log(`This will never log out: ${json}`)\n  })\n  .catch(error => {\n    console.error(error.message)\n  })\n")),Object(o.b)("hr",null),Object(o.b)("p",null,"That’s it. That’s the whole post. Though the snippet is ultimately pretty simple (it’s 20 lines without whitespace and comments) writing this provided me with three major benefits: it forced me to abstract the function to the most reusable version I could, it gave me an opportunity to research ",Object(o.b)("inlineCode",{parentName:"p"},"AbortController")," to make sure I knew exactly how it behaved, and it provided a place where I can come find this snippet in the future instead of rooting through old projects."))}c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-blog-fetch-with-timeout-index-mdx-4e5ff46ac778a918ab23.js.map