{"version":3,"sources":["webpack:///./src/pages/blog/fetch-with-timeout/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"weAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,6CAA4B,mBAAGC,WAAW,KAAQ,CAC9C,KAAQ,+DADgB,aAA5B,+GAEsI,mBAAGA,WAAW,KAAQ,CACxJ,KAAQ,YAD0H,cAFtI,2HAImJ,mBAAGA,WAAW,KAAQ,CACrK,KAAQ,mCADuI,SAJnJ,KAOA,oDAAmC,0BAAYA,WAAW,KAAvB,SAAnC,4FAAiL,mBAAGA,WAAW,KAAQ,CACnM,KAAQ,oEADqK,OAAjL,gBAEiC,mBAAGA,WAAW,KAAQ,CACnD,KAAQ,oCADqB,yCAFjC,iHAIoK,mBAAGA,WAAW,KAAQ,CACtL,KAAQ,kGACP,0BAAYA,WAAW,KAAvB,iBANL,UAM4E,mBAAGA,WAAW,KAAQ,CAC9F,KAAQ,sEADgE,iBAErD,0BAAYA,WAAW,KAAvB,SAFqD,uBAN5E,0EAQ8K,mBAAGA,WAAW,KAAQ,CAChM,KAAQ,qEACP,0BAAYA,WAAW,KAAvB,oBAVL,cAWA,qBAAG,0BAAYA,WAAW,KAAvB,mBAAH,uHAAsL,mBAAGA,WAAW,KAAQ,CACxM,KAAQ,8CAD0K,yBAEvJ,kBAAIA,WAAW,KAAf,aAFuJ,uBAAtL,gDAEgJ,mBAAGA,WAAW,KAAQ,CAClK,KAAQ,mDADoI,2BAFhJ,qDAI0F,0BAAYA,WAAW,KAAvB,UAJ1F,kDAI+L,0BAAYA,WAAW,KAAvB,SAJ/L,iHAIkW,mBAAGA,WAAW,KAAQ,CACpX,KAAQ,sEADsV,2DAJlW,+HAOA,6BAAY,0BAAYA,WAAW,KAAvB,mBAAZ,wGAAgL,0BAAYA,WAAW,KAAvB,SAAhL,yEAA2S,0BAAYA,WAAW,KAAvB,QAA3S,yIACA,sBACE,kBAAIA,WAAW,MAAf,yBAA8C,0BAAYA,WAAW,MAAvB,oBAC9C,kBAAIA,WAAW,MAAf,YAAiC,0BAAYA,WAAW,MAAvB,cAAjC,yCAAkI,0BAAYA,WAAW,MAAvB,SAAlI,WACA,kBAAIA,WAAW,MAAf,yBAA8C,0BAAYA,WAAW,MAAvB,UAA9C,OAAyG,0BAAYA,WAAW,MAAvB,SAAzG,sBAEF,iDACA,6EAA4D,0BAAYA,WAAW,KAAvB,SAA5D,kFAAgM,0BAAYA,WAAW,KAAvB,OAAhM,uBAAuQ,0BAAYA,WAAW,KAAvB,eAAvQ,iBAAgV,0BAAYA,WAAW,KAAvB,SAAhV,yKAA2iB,kBAAIA,WAAW,KAAf,QAA3iB,iHACA,oDAAmC,0BAAYA,WAAW,KAAvB,oBAAnC,8DAA8J,0BAAYA,WAAW,KAAvB,SAA9J,QAAwN,0BAAYA,WAAW,KAAvB,mBAAxN,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,mvCAoCL,wFAAuE,0BAAYA,WAAW,KAAvB,SAAvE,mHAA4O,0BAAYA,WAAW,KAAvB,QAA5O,+DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yhBAkBL,uBACA,+TAA8S,0BAAYA,WAAW,KAAvB,mBAA9S,mKAKJJ,EAAWK,gBAAiB","file":"component---src-pages-blog-fetch-with-timeout-index-mdx-4e5ff46ac778a918ab23.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"C:/Users/Nikhil17/Desktop/CodeBase/portfolio/src/templates/BlogPost.jsx\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`I’m a big fan of the `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\"\n      }}>{`Fetch API`}</a>{`. I use it regularly in all sorts of projects, including this site and the API that powers the stats on the `}<a parentName=\"p\" {...{\n        \"href\": \"/about/\"\n      }}>{`about page`}</a>{`. However it isn’t always as clear how to do things like error handling and request timeouts as it is in libraries like `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/axios/axios\"\n      }}>{`Axios`}</a>{`.`}</p>\n    <p>{`If you’re not familiar with `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{`, it’s a native API that massively simplifies making AJAX requests compared to the older `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/XMLHTTPRequest\"\n      }}>{`XHR`}</a>{` method, and `}<a parentName=\"p\" {...{\n        \"href\": \"https://caniuse.com/#feat=fetch\"\n      }}>{`it’s supported in all modern browsers`}</a>{`. When it initially landed, however, there was no easy way to handle request timeouts. You could fake it with `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\"\n      }}><inlineCode parentName=\"a\">{`Promise.race`}</inlineCode></a>{` or by `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/github/fetch/issues/175#issuecomment-216791333\"\n      }}>{`wrapping your `}<inlineCode parentName=\"a\">{`fetch`}</inlineCode>{` in another Promise`}</a>{`, but these solutions don’t actually cancel the request. This is where `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\"\n      }}><inlineCode parentName=\"a\">{`AbortController`}</inlineCode></a>{` comes in.`}</p>\n    <p><inlineCode parentName=\"p\">{`AbortController`}</inlineCode>{` is an API that, much like its name and my previous sentence suggests, allows us to abort (cancel) requests. Though `}<a parentName=\"p\" {...{\n        \"href\": \"https://caniuse.com/#feat=abortcontroller\"\n      }}>{`browser support isn’t `}<em parentName=\"a\">{`wonderful`}</em>{` at time of writing`}</a>{`, it can be used in most modern browsers and `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/mo/abortcontroller-polyfill\"\n      }}>{`polyfills are available`}</a>{`. The API itself has a very small surface area: a `}<inlineCode parentName=\"p\">{`signal`}</inlineCode>{` property to attach to request objects, and an `}<inlineCode parentName=\"p\">{`abort`}</inlineCode>{` method to actually cancel the request. Because the API is so simple, it’s very flexible — Jake Archibald has `}<a parentName=\"p\" {...{\n        \"href\": \"https://developers.google.com/web/updates/2017/09/abortable-fetch\"\n      }}>{`a fairly in-depth article on the Google Developers blog`}</a>{` going over various cancellation scenarios, as well as the history behind the API, and I highly recommend giving it a read.`}</p>\n    <p>{`With `}<inlineCode parentName=\"p\">{`AbortController`}</inlineCode>{`, it becomes trivial to cancel a request if it doesn’t resolve before a given period of time: if the `}<inlineCode parentName=\"p\">{`abort`}</inlineCode>{` method is called before the request resolves (or before the response `}<inlineCode parentName=\"p\">{`Body`}</inlineCode>{` is consumed), the request is cancelled; if it’s called after, the browser just ignores the call. To put it all together, we need to:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Create an instance of `}<inlineCode parentName=\"li\">{`AbortController`}</inlineCode></li>\n      <li parentName=\"ol\">{`Create a `}<inlineCode parentName=\"li\">{`setTimeout`}</inlineCode>{` function that calls the controller’s `}<inlineCode parentName=\"li\">{`abort`}</inlineCode>{` method`}</li>\n      <li parentName=\"ol\">{`Pass the controller’s `}<inlineCode parentName=\"li\">{`signal`}</inlineCode>{` to `}<inlineCode parentName=\"li\">{`fetch`}</inlineCode>{`’s options object`}</li>\n    </ol>\n    <h2>{`Putting It All Together`}</h2>\n    <p>{`First, because we’re basically writing a shim around `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{`, I’m going to add an extra little perk. If the response doesn’t return in the `}<inlineCode parentName=\"p\">{`200`}</inlineCode>{` range (that is, if `}<inlineCode parentName=\"p\">{`response.ok`}</inlineCode>{` evaluates to `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`), we’re going to throw an error. We absolutely do not need to do this — we could just catch our timeout and the function would work the same (we actually don’t even `}<em parentName=\"p\">{`need`}</em>{` to do that). However, I always perform this check anyways, so this removes a lot of boilerplate code for me.`}</p>\n    <p>{`Anyways, here is my generic `}<inlineCode parentName=\"p\">{`fetchWithTimeout`}</inlineCode>{` function. It should work in any environment that supports `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`AbortController`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const fetchWithTimeout = (uri, options = {}, time = 5000) => {\n  // Lets set up our \\`AbortController\\`, and create a request options object\n  // that includes the controller's \\`signal\\` to pass to \\`fetch\\`.\n  const controller = new AbortController()\n  const config = { ...options, signal: controller.signal }\n\n  // Set a timeout limit for the request using \\`setTimeout\\`. If the body of this\n  // timeout is reached before the request is completed, it will be cancelled.\n  const timeout = setTimeout(() => {\n    controller.abort()\n  }, time)\n\n  return fetch(uri, config)\n    .then(response => {\n      // Because _any_ response is considered a success to \\`fetch\\`,\n      // we need to manually check that the response is in the 200 range.\n      // This is typically how I handle that.\n      if (!response.ok) {\n        throw new Error(\\`\\${response.status}: \\${response.statusText}\\`)\n      }\n\n      return response\n    })\n    .catch(error => {\n      // When we abort our \\`fetch\\`, the controller conveniently throws a named\n      // error, allowing us to handle them separately from other errors.\n      if (error.name === 'AbortError') {\n        throw new Error('Response timed out')\n      }\n\n      throw new Error(error.message)\n    })\n}\n`}</code></pre>\n    <p>{`Using the function is fairly straightforward. Because we return `}<inlineCode parentName=\"p\">{`fetch`}</inlineCode>{` directly, we can use it in much the same way; the only change should be the addition of a third parameter (our `}<inlineCode parentName=\"p\">{`time`}</inlineCode>{` argument) and the extra error handling we discussed above.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// This example _always_ logs the error, because I'm telling httpstat.us to wait\n// at least 1s before responding, but setting the timeout threshold to 500ms.\n// Also, this could definitely be written in async/await if you preferred.\nfetchWithTimeout(\n  'https://httpstat.us/200?sleep=1000',\n  { headers: { Accept: 'application/json' } },\n  500\n)\n  .then(response => response.json())\n  .then(json => {\n    console.log(\\`This will never log out: \\${json}\\`)\n  })\n  .catch(error => {\n    console.error(error.message)\n  })\n`}</code></pre>\n    <hr></hr>\n    <p>{`That’s it. That’s the whole post. Though the snippet is ultimately pretty simple (it’s 20 lines without whitespace and comments) writing this provided me with three major benefits: it forced me to abstract the function to the most reusable version I could, it gave me an opportunity to research `}<inlineCode parentName=\"p\">{`AbortController`}</inlineCode>{` to make sure I knew exactly how it behaved, and it provided a place where I can come find this snippet in the future instead of rooting through old projects.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}